(* Authors:
 * H.A. Coelho Dias (1531484)
 * R.E.L. van Dijk (0963283)
 *)

(* Definitions:
 * Spy = Compromised agent/device
 * B = Base station
 * S = Server
 * D = Devices
 * kBD = Symmetric key between B and D
 * pk(X) = Public key of X 
 * n = Nonce
 * c = Secure connection
 *)

(* Protocol:
 * D begin Connect(D, n, S)
 * D -> B: D, S, {S, n}_kBD         (maybe add pwd here)
 * B -> S: {|D, S, n|}_pk(S)
 * S -> B: {|D, n, c|}_pk(B)
 * B -> D: {S, n, c}_kBD
 * D -> S: n    (via c)
 * S end Connect(D, n, S)
 *)

(* Variable declarations: *)
free net.                                         (* Public communication network *)
free Spy, B, D, S.                                (* See definitions *)

private free kBD.                                 (* Assume kBD is privately shared *)

(* Function declarations: *)
fun pk/1.                                         (* Get public key *)
private fun sk/1.                                 (* Get secret key *)
fun sencrypt/2.                                   (* Symmetric encryption *)
reduc sdecrypt(sencrypt(m, k), k) = m.            (* Symmetric decryption *)
fun encrypt/2.                                    (* Assymetric encryption *)
reduc decrypt(encrypt(m, pk(a)), sk(a)) = m.      (* Assymetric decryption *)

(* Encoding of properties / queries: *)
query attacker:c.                                 (* Can external attacker get c? *)
query evinj:end(x,y,z) ==> evinj:start(x,y,z).    (* Verify authenticity via events *)

(* Process declarations: *)
let device =
  new n;
  event start(D, n, S);                           (* Start of our protocol *)
  out(net, (D, S, sencrypt((S, n), kBD)));        (* D -> B: D, S, {S, n}_kBD *)
  in(net, m);                                     (* Receive encrypted message m *)
  let (=n, D, c) = sdecrypt(m, kBD) in            (* B -> D: {S, n, c}_kBD *)
    out(c, n).                                    (* D -> S: n    (via c) *)

let server =
  in(net, m);
  let (D, S, n) = decrypt(m, sk(S)) in            (* B -> S: {|D, S, n|}_pk(S) *)
    new c;                                        (* Fresh secure connection *)
    out(net, encrypt((D, n, c), pk(B)));          (* S -> B: {|D, n, c|}_pk(B) *)
    in(c, =n);                                    (* Check validity of incoming nonce n *)
    event end(D, n, S).                           (* End of our protocol *)

let base =
  in(net, (D, S, nenc));
  let (=S, n) = sdecrypt(nenc, kBD) in            (* D -> B: D, S, {S, n}_kBD *)
    out(net, encrypt((D, S, n), pk(S)));          (* B -> S: {|D, S, n|}_pk(S) *)
    in(net, m);                                   (* S -> B: {|D, n, c|}_pk(B) *)
    let (=D, =n, c) = decrypt(m, sk(B)) in        (* B -> D: {S, n, c}_kBD *)
      out(net, sencrypt((S, n, c), kBD)).         (* D -> S: n    (via c) *)

let compromised =
  out(net, sk(Spy)).                              (* Give secret key Spy to the attacker *)

(* Program execution: *)
process
  !server | !device | !base | compromised
