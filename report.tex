\documentclass[a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{listings}
\usepackage{enumitem}
\lstset
{ %Formatting for code in appendix
    basicstyle=\footnotesize,
    numbers=left,
    showstringspaces=false,
    breaklines=true,
}

%\title{Sorting of Binary Search Trees in Coq}

\title{%
  Binary Search Trees in Coq \\
  \large Proving with Computer Assistance Assignment}
    
\author{Henrique Dias (1531484), Venislav Varbanov (284401)}
\date{March 2021}

\begin{document}

\maketitle

\section{Introduction}

The goal of this assignment is to formally define trees and binary search trees of natural numbers, as well as define some of its common operations, such as sort, insert and tree minimum value.

A binary search tree (BST) is a tree that for each of its nodes, its left subtree only stores values smaller than the value of the node, and the right subtree only stores values larger than the value of the node.

%   Explanation of the problem and your approach to it.

%Do not make it too long. 15 pages is the absolute maximum but normally it should be much shorter. Keep in mind that longer does not mean better!
%What you should write:
%   Explanation of the problem and your approach to it.
%   Description of the main definitions and the line of your proofs (e.g. sublemmas you used). If you had some alternative ideas to solve those problems describe them and explain your choice for the solution to this problem.
%   Write about your experience with the prover. What did you like, what you did not like etc.
%   Possibly add the Coq code as an appendix. (But note that you should deliver the Coq .v files separately anyway.)
%What you should not write
%   Do not unnecessarily repeat the code. Refer to appendix and quote the code only to illustrate something.
%   Do not write obvious things! Description of the proofs of the shape: "the goal is as follows so we apply this tactic and that is what we get..." are useless.

\section{Part I: Sorting a Tree}

\paragraph{Definition of a BST}

The definition of a BST (\texttt{bst}, line 26) is a recursive function where, for each left and right node, we check if its value is larger or smaller than the ones of all of its children. To check those conditions, we defined a helper function \texttt{tree\_forall} that for a certain condition and certain node, checks if the node and its children satisfy the condition.

\paragraph{Insert Operation}

The insert operation (\texttt{insert}, line 38) can be applied to a BST and is recursive by nature. To prove the correctness of the insertion, we started by proving a sublemma \texttt{insert\_forall} (line 50).

The sublemma proves that for a certain condition and tree, if all the elements of the tree meet the condition, the condition will still be met by all nodes after the insert operation. The proof is by induction and simple.

To prove the correctness of insertion, i.e., to prove that inserting a new value in a BST produces a BST, we made a proof by induction (line 63) that leverages the sublemma \texttt{insert\_forall}, applying the necessary conditions that a BST needs to meet on its left and right branches.

\paragraph{Sort Operation}

The sort operation (\texttt{sort}, line 93) transforms an arbitrary tree into a BST. To do so, we first transform the tree into a list (line 79) and then we rebuild from the list (line 86) by simply using the insert operation on all list elements.

To prove that the sort operation results in a BST (line 104), we proved a sublemma that shows that any tree built from a list is a BST. When building a tree from a list, we simply use the insert operation from an empty tree and insert all elements consecutively. Since the \texttt{insert} operation always results in a BST, it follows that \texttt{sort} results in a BST.

We also prove that the sorted tree has the exact same elements of the initial tree (\texttt{sorted\_occurs}, line 168). To prove this, we first defined the function \texttt{occurs} (line 111) that checks if a certain element is present on a tree. Then, we define three sublemmas:

\begin{itemize}
    \item \texttt{occurs\_insert} (line 118), which proves that, for two numbers $n$ and $m$, if $m=n$ or n occurs in the tree, then $n$ occurs in the tree after inserting $m$. The "or" operation is needed for the case where the initial tree is an empty tree, i.e., is a leaf. In that case, it is impossible for $n$ to initially occur in the tree.
    \item \texttt{occurs\_list\_tree} (line 155), which proves that if a list contains a number, then it will occur in the tree built from that list, and vice-versa.
    \item \texttt{occurs\_tree\_list} (line 136), which proves that if a number occurs in a tree, then it will also occur in its list transformation, and vice-versa.
\end{itemize}

Using this sublemmas, it is trivial to prove \texttt{sorted\_occurs} by induction.

\section{Part II: The Minimum of a BST}

\paragraph{Tree Minimum} The tree minimum function (\texttt{treeMin}, line 195) is defined recursively using the builtin \texttt{Nat.min} function. It returns an \texttt{option nat}, representing the minimum value in the tree. In case the tree is a leaf, \texttt{None} is returned.

The correctness of the function is proved through lemma\texttt{treeMin\_is\_min} (line 519), which proves that for all trees, if the tree has a natural number, then it occurs in the tree and it is smaller or equal than all of its elements. To prove this lemma, we had to split it into many sublemmas:

\begin{itemize}
    \item \texttt{treeMin\_occurs} (line 197), which proves that if a tree has a minimum, then it occurs in the tree. The proof is quite long as we need to prove for the different ramifications of the tree during the execution of \texttt{treeMin} and \texttt{occurs}.
    \item \texttt{treeMin\_is\_min} (line 510), which proves that if a tree has a minimum, it is smaller or equal than all of the elements of the tree. This sublemma is also divided into two further sublemmas described below and it is a direct consequence of them.
    \item \texttt{treeMin\_helper\_smaller\_than\_min\_is\_min} (line 336) - TODO
    \item \texttt{treeMin\_helper\_min\_is\_smaller} (line 446) - TODO
\end{itemize}
 
\paragraph{Leftmost Node}

TODO: leftmost and leftmost BST is tree min

\paragraph{Search a BST}

TODO: search for BST, correctness

\appendix

\section{Code}

\lstinputlisting{bst.v}

\end{document}
